Information Retrieval Final Project - Collaborative Filtering Recommendation System for Anime

Background:
-----------

Anime is a largely popular form of media consisting of Japanese animated TV shows and movies, and 
accounts for around 60% of all animated television shows. MyAnimeList (MAL) is an anime database and 
online community (equivalent to something like IMDB) that has millions of active accounts, and a
majority of people who watch anime keep track of their shows and rate them on this website. These 
shows are relatively short (usually  12-24 episodes long) so users tend to watch many and thus take 
advantage of this tracker and ratings system (active users have an average of ~200 shows rated). With 
this large store of user information and also the desire to find new shows to watch on a regular basis, 
it seems that a recommendation system for anime could benefit greatly. However, the extent of recommendations
on MyAnimeList are manual recommendations that users make for each show. Example: When looking at Show A, you
see that 15 users have recommended Show B since it is similar for reasons x, y, and z. Most users don't 
bother to recommend shows this way or look at these recommendations as they are quite unreliable and only based
on a particular show. Using a user-based collaborative filtering system, we could vastly improve recommendations
by taking into account a user's entire list and computing similarities between other users, and recommending 
shows that the most similar users liked. 

Step 1 - Data Collection:
--------------------------

The first step in the collaborative filtering process is to generate a table of many user ratings. I would also
like information for the anime and users (this is not entirely necessary but allows us to make a user-friendly
and aesthetic website to display recommendation results with some associated info). To retrieve data from MAL,
I use the unofficial Jikan API (which acts in accordance to the MAL terms of service). 

https://github.com/jikan-me/jikan-rest#installation

I installed an instance of this REST API server locally to easily query and receive JSON data for any 
MAL-related info we need. MAL terms of service states the following in regards to web robots/scrapers:

"You also agree not to use or launch any automated system, including without limitation, "offline readers," 
"spiders," "robots," etc., that accesses the Service in a manner that sends more request messages to the 
Company servers than a human can reasonably produce in the same period of time by using a conventional on-line 
web browser."

Thus we limit requests to the API to 1 request/second which a human could reproduce (MAL allows ~2/second before
rate limiting, but we limit to 1 to ensure we don't abuse/overload the servers). After launching the local API
instance by following the instructions on the Jikan README, we use several scripts to aggregate the data we need. 

First, we need many user profiles. There is no publicly available list of MAL users, but if you know the username,
you can freely view their ratings as long as their profile is public, which means we can download user data from the
API given usernames. In order to get a list of active users on MAL, I query https://myanimelist.net/users.php which
gives the 20 most recent users on the site. We do 1 request every 3 seconds using the script: scrapeusers.py (output 
piped to txt file). The API does not have this capability, so we parse the HTML from the site ourselves to get 20 users 
every 3 seconds. There are enough active, unique users that each query more or less gives 20 unique usernames. At the end, 
after removing duplicates, we obtain ~30,000 usernames of active profiles, which is convenient since the most recent anime 
are also  likely to have ratings in this recewntly active user group, which will help our recommender target newer shows.

After getting this list of usernames, we use the API to get ratings for each user in getratings.py. This generates a
TSV file, users_all.tsv, for users with user id, username, and mean rating of their profile (which is computed here and 
stored for efficiency in the recommendation system later). It also generates a TSV file for ratings, ratings_all.tsv, with 
user id, MAL id, and rating (each anime has a MAL associated id that we make use of for convenience). 

Next, we get a TSV file for general info about each anime. We use idfromratings.py to get a list of unique MAL ids from the 
ratings TSV (with 30000 users, this covers basically all of the anime in the database). Then we use getanimeinfo.py to create 
a TSV file, anime_info_all.tsv, which contains basic information such as title, MAL score, genres, episode count, image link, 
etc. We also keep track of any prequels these shows have for later use (we generally don't want sequels to be recommended). 


The final result (after many hours of retrieving data) are three files: users_all.tsv with ~32k users, ratings_all.tsv with ~4.8
million ratings, and anime_info_all.tsv with ~15k anime. 


Step 2 - Database Storage and Queries for Recommendations
----------------------------------------------

To store this data and compute recommendations efficiently, we use a PSQL database. Data from TSV files can be copied quite easily
to tables using the following commands:

CREATE TABLE anime_info (mal_id INT PRIMARY KEY UNIQUE, title TEXT UNIQUE, season TEXT, genres TEXT[], type TEXT, episodes INT, 
score FLOAT, members INT, img TEXT, prequels_id INT[], is_sequel BOOLEAN); 

COPY anime_info FROM 'D:/Documents/animequery/anime_info_final.tsv' DELIMITER '\t' CSV HEADER;

CREATE TABLE users (user_id INT PRIMARY KEY UNIQUE, username TEXT UNIQUE, mean_rating FLOAT);

COPY users FROM 'D:/Documents/animequery/users_final.tsv' DELIMITER '\t' CSV HEADER;

CREATE TABLE ratings (user_id INT, mal_id INT, rating FLOAT, PRIMARY KEY(user_id, mal_id));

COPY ratings FROM 'D:/Documents/animequery/ratings_final.tsv' DELIMITER '\t' CSV HEADER;

After populating the database, we can finally start doing some recommendations. I am choosing to do user-based collaborative
filtering. The basic process for this is:
1. Take a user we want recommendations for and compute a cosine similarity between them and every other user
2. Take the most similar users and recommend anime that they rate high (relative to their mean rating). 

We achieve this using custom PSQL queries which makes the process quick and efficient. In more detail:

1. Precompute a table for the cosine similarity denominator (magnitude of vector for each user). This only happens once
since it is a permanent table - we update this each time a new user is added.
CREATE TABLE normalize AS (SELECT user_id, SQRT(SUM(rating * rating)) AS magnitude FROM ratings GROUP BY user_id);

2. Add the user that wants recommendations into the database. This is done in a hybrid of Python and PSQL in app.py (main
Flask web app file) - this will be explained more in the Website Development section.

3. Compute the cosine similarity numerator (dot product between new user <user_id> and all exisiting users). To do this, we 
join two ratings tables together on shared anime ids and take the sum of all products of ratings for shared anime:
CREATE TEMPORARY TABLE cosinedot AS (SELECT r1.user_id AS user_1, r2.user_id AS user_2, SUM(r1.rating * r2.rating) AS 
dot FROM ratings r1 INNER JOIN ratings r2 ON r1.mal_id = r2.mal_id AND r1.user_id = <user id> WHERE r2.user_id != <user id> 
GROUP BY user_1, user_2 ORDER BY dot DESC);

4. Divide the numerator by denominator and get a table with the final similarities. We limit the nearest neighbors to 20.
CREATE TEMPORARY TABLE cosinesim AS (SELECT cosinedot.user_1 AS user_1, cosinedot.user_2 AS user_2, 
cosinedot.dot / (n1.magnitude * n2.magnitude) AS sim FROM cosinedot INNER JOIN normalize AS n1 on 
cosinedot.user_1 = n1.user_id INNER JOIN normalize AS n2 on cosinedot.user_2 = n2.user_id ORDER BY sim desc LIMIT 20);

5. We take the most similar users and compute the differences between their ratings and their
mean rating; this gives a positive weight to anime that they rate higher than normal. We weight these differences based on how similar
the user is to the original user and normalize, and create a table with a final deviation for each anime.
CREATE TEMPORARY TABLE prediction_dev AS (SELECT c.user_1 as uid, r.mal_id, SUM(c.sim * (r.rating - u.mean_rating)) / SUM(c.sim) 
AS score_dev FROM cosinesim AS c INNER JOIN ratings AS r ON c.user_2 = r.user_id INNER JOIN users as u on c.user_2 = u.user_id 
GROUP BY uid, mal_id ORDER BY uid, score_dev DESC);

6. We predict scores by taking the deviation for each anime and adding it to the mean rating for the original user (MAL scores are on 
a scale from 1-10, so we expect predictions to be around this range). We also add a small 10% weight to the actual MAL score, which helps 
filter out recommended shows with very low scores:
SELECT p.mal_id, ((p.score_dev + u.mean_rating) * 0.90 + (a.score * 0.10)) AS predicted_score FROM prediction_dev p, users u, anime_info a 
WHERE u.user_id = <user_id> AND a.mal_id = p.mal_id ORDER BY predicted_score DESC;

This final step outputs a list of MAL ids and predicted scores for each, starting from the highest predicted score.


Step 3 - Website for Displaying Results
----------------------------------------------
Now that recommendations can be computed, we would like a visually intuitive and appealing way to display the results, so I made a website 
in Flask (code base of Python and web hosting using Heroku) that stores the database and allows a user to enter their username to get 
recommendations (contained in anirec_server directory). We query MAL for the user's profile and insert it into the database, and then make recommendations as previously described. 
The recommendation list is then passed to an HTML template and parsed using the Jinja template engine, which allows us to create flexible and 
filterable recommendations that are easily displayed on the webpage, as well as "More Info" popups for each show and a link to the original 
MAL page. 


Step 4 - Evaluation
-----------------------
We use a common evaluation system for recommendation systems - Root Mean Squared Error (RMSE). This is the evaluation used for the popular
Netflix Prize as well, which had people attempt to minimize the RMSE value for Netflix recommendations. 



